
import java.awt.*;
import java.awt.event.*;
import java.io.File;
import java.io.IOException;
import javax.imageio.ImageIO;
import javax.swing.*;

@SuppressWarnings("serial")
/**
 * @author adibhati
 * The Board is what the game is played on,
 * contains information about the tiles to be 
 * cleared and responds to user clicks. 
 */
public class Board extends JPanel {
	
	private Image grass; 
	private Icon intro; 
	private int tileDim = 50; 
	private int dim = -1; 
	private Tile[][] boardTiles; 
	private int[][] hiddenBoard; 
	private int[][] adjacents; 
	private final String GRASS_FILE = "pics/grass.png";
	private final String INTRO_FILE = "pics/intro.png";
	private JLabel status;
	private boolean isPlaying = false;
	private boolean isBombed = false; 
	private Timer timer; 
	private final int BOARD_DIM; 
	
	//keeps track of stats for board
	private int numFlagged = 0; 
	private int numRevealed = 0; 
	private int numMines = -1; 
	private boolean exited; 
	
	// Update interval for timer, in milliseconds
    public static final int INTERVAL = 105;
    
    // Checks to see if first click has been made
    boolean hasClicked = false; 
    
	/**
	 * overloaded constructor for testing
	 * @param status The JLabel representing game status
	 * @param mines The number of mines on the board
	 * @param dim The dimension of the board
	 */
    public Board(JLabel status, int mines, int dim) {
    	numMines = mines; 
    	this.dim = dim; 
    	this.status = status; 
    	BOARD_DIM = dim*tileDim; 
    	
    	boardTiles = new Tile[dim][dim]; 
		hiddenBoard = new int[dim][dim]; 
		adjacents = new int[dim][dim]; 
		initializeTiles(); 
    }
    
    /**
	 * Constructor that creates a pop up game menu and 
	 * prompts the user to enter in the dimension of the
	 * board and an appropriate number of mines. A board is
	 * then generated by randomly placing the specified number
	 * of mines in the correct size board. 
	 * @param status The JLabel representing game status
	 * @param mines The number of mines on the board
	 * @param dim The dimension of the board
	 */
    public Board(JLabel status) {
		
		this.status = status; 
		String[] options = {"Start", "Instructions"};
		if (intro == null) {
			intro = new ImageIcon(INTRO_FILE); 
		}
			
		int choice = 1; 
		int dimLimit = 15; 
		while(!((dim>2 && dim < dimLimit) && ((numMines >0 
				&& numMines <= dim*dim/2)))) {
			dim = -1; 
			numMines = -1;
			do {
				choice = JOptionPane.showOptionDialog(null, 
						"Welcome to Minesweeper!", "MINESWEEPER",
				JOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE, 	
						intro, options, options[0]);
				if(choice == 1) {
					String instructions = "The goal of minesweeper is to be able to clear " +
     							"a square board by \nrevealing all" 
        						+ " the tiles that aren't mines. \n \nYou can reveal a tile by " +
        						"left clicking. If you reveal a mine, you lose, \nand if you "
        						+ "reveal a grass tile it tells you how many mines are adjacent\n" +
        						"to it. You can also right-click a tile to flag it in helping keep \n"+
        						"track of the positions of potential mines. \n \n "
        						+ "Use COMMAND+Q to quit from the main menu or the game state. \n"
        						+ "You can also use the red x to quit from the game state."; 
					JOptionPane.showMessageDialog(null, instructions, "Instructions", 
							JOptionPane.INFORMATION_MESSAGE, intro);
				}
				else if(choice != 1 && choice != 0) {
					exited = true;
					break;
				}
			} while(choice == 1); 
        
			if(!exited) {
				do {
					try {
						String x = (String) JOptionPane.showInputDialog(null, "Enter "
	        			+ "a dimension for the board (must be from 3 to " 
								+ (dimLimit-1) + ")", "Game Parameters", 
								JOptionPane.INFORMATION_MESSAGE, intro, null, ""); 
						dim = Integer.parseInt(x); 
						System.out.println("dim = "+ dim); 
					} catch(Exception e) {
						break; 
					}
				
				} while(!(dim>2 && dim < dimLimit));
			}
			System.out.println("before loop: " + dim); 
			if((dim>2 && dim < dimLimit)) {
				do {
					try {
						String x = (String) JOptionPane.showInputDialog(null, "Enter "
    						+ "the number of mines (must be from 1 to " 
    						+ dim*dim/2+")", "Game Parameters", 
    						JOptionPane.INFORMATION_MESSAGE, intro, null, ""); 
						numMines = Integer.parseInt(x); 
						System.out.println("numMines: " + numMines); 
					} catch(Exception e) {
    				break; 
					}	
				} while(!((numMines >0 && numMines <= dim*dim/2))); 
				System.out.println("corecct mines "+ numMines); 
			}
 
		}
		
		
		
		// creates border around the court area, JComponent method
        setBorder(BorderFactory.createLineBorder(Color.BLACK));
   
		BOARD_DIM = dim*tileDim; 
		boardTiles = new Tile[dim][dim]; 
		hiddenBoard = new int[dim][dim]; 
		adjacents = new int[dim][dim]; 
		initializeTiles(); 
		
		//load picture of grass 
		try {
	           if (grass== null) {
                grass = ImageIO.read(new File(GRASS_FILE));
            }
        } catch (IOException e) {
            System.out.println("Internal Error:" 
            			+ e.getMessage());
            }
		
		//mouseListener to listen for clicks
		addMouseListener(new MouseAdapter() {
			public void mouseClicked(MouseEvent e) {
				
				Point p = e.getPoint(); 
				
				double x = p.getX();
				double y = p.getY(); 
				
				int i = (int)x/tileDim;
				int j = (int)y/tileDim; 
				
				if(!hasClicked) {
					setMines(i, j); 
					hasClicked = true;
				}
				if 
				(SwingUtilities.isRightMouseButton(e)) {
			        flag(i, j); 
			    }
				if 
				(SwingUtilities.isLeftMouseButton(e)) {
		            reveal(i,j); 
			     }
			}
         });
		 
		 timer = new Timer(INTERVAL, new ActionListener() {
	            public void actionPerformed(ActionEvent e) {
	                
	            	tick();
	            }
	     });
		 timer.start();
	}
	
	
	/**
	 * Repeated method that keeps updating the game once board set.
	 * Constantly checks for game ending conditions to see when
	 * user is not allowed to play anymore and informs them. 
	 */
    void tick() {
		if(isBombed && isPlaying) {
			repaint();
			status.setText("YOU LOSE"); 
			isPlaying = false; 
			isBombed = false; 
		}
		if(isPlaying) {
			String msg = numFlagged
					+ "/" + numMines + " flagged"; 
			if(numRevealed == dim*dim - numMines) {	
				status.setText("YOU WIN!!!"); 
				isPlaying = false; 
			}
			else if(numFlagged >= numMines) {
				String msg2 = msg + " "
						+ "... something's wrong";  
				status.setText(msg2);
			}
			else {
				status.setText(msg);
			}
			repaint(); 
		} 
		
	}
	
	/**
	 * Ensures first tile clicked on isn't a mine
	 * @param x The x coordinate of the first tile clicked on (With a top-left origin)
	 * @param y The y coordinate of the first tile clicked on (With a top-left origin)
	 * 
	 */
	public void setMines(int x, int y){
		if(hiddenBoard[x][y] == 1) {
			Point p = firstEmpty();  
			int i = (int)p.getX();
			int j = (int)p.getY(); 
			hiddenBoard[x][y] = 0;
			hiddenBoard[i][j] = 1; 
			setAdjacent(x, y);
			setAdjacent(i,j); 
			setTile(x, y);
			setTile(i, j); 
		}	
	}
	/**
	 * Finds the first Grass Tile starting from the top left mine and traversing
	 * row by row
	 * @return A Point whose coordinates represent the array placement of the first Grass
	 * tile in the hiddenBoard array
	 */
	public Point firstEmpty() {
		for(int i = 0; i < dim; i++) {
			for(int j =0; j < dim; j++) {
				if(hiddenBoard[i][j] == 0) {
					return new Point(i,j); 
				}
			}
		}
		return new Point(0,0); 
	}
		
	/**
	 * Sets the 2D array for counts of adjacent mines of every Tile. 
	 */
	private void setAdjacent() {
		for(int i = 0; i < dim; i++) {
			for( int j = 0; j < dim; j++) {
				//have gotten to certain cell, look around it
				int adj = 0; 
				for(int x = i-1; x <= i+1; x++) {
					for(int y = j-1; y <= j+1; y++) {
						if(inBounds(x) && inBounds(y)) {
							if(hiddenBoard[x][y] ==1) {
								adj++; 
							}
						}
					}
				} 
				adjacents[i][j] = adj; 
				
			}
		}
	}
	
	/**
	 * Sets the 2D array for counts of adjacent mines of a particular Tile. 
	 * @param i The x coordinate of the Tile of interest (With a top-left origin)
	 * @param j The x coordinate of the Tile of interest (With a top-left origin)
	 */
	private void setAdjacent(int i, int j) {
		int adj = 0; 
		for(int x = i-1; x <= i+1; x++) {
			for(int y = j-1; y <= j+1; y++) {
				if(inBounds(x) && inBounds(y)) {
					if(hiddenBoard[x][y] ==1) {
						adj++; 
					}
				}
			}
		} 
		adjacents[i][j] = adj; 
		
	}
	
	/**
	 * Checks if a coordinate is possible to be within the board. 
	 * @param x Coordinate value that needs to be checked 
	 * @return boolean stating if the value is in bounds or not
	 */
	private boolean inBounds(int x) {
		if(x < dim && x>= 0) {
			return true; 
		}
		return false; 
	}
	
	/**
	 * Creates a 2D array of Tiles based on the values in the 
	 * hiddenBoard
	 */
	public void setTiles() {
		for(int i = 0; i < dim; i++) {
			for(int j = 0; j < dim; j++) {
				int adj = adjacents[i][j]; 
				if(hiddenBoard[i][j] == 1) {
					Tile t = new Mine(tileDim, 
							adj, i*tileDim, j*tileDim);
					boardTiles[i][j] = t; 
				}
				else {
					Tile t = new Grass(tileDim, 
							adj, i*tileDim, j*tileDim);
					boardTiles[i][j] = t; 
				}
			}
		}
	}
	
	/**
	 * Creates an appropriate Tile at a particular position in the
	 * 2D array of Tiles. 
	 * @param x The x coordinate of the starting Tile (With a top-left origin)
	 * @param y The y coordinate of the starting Tile (With a top-left origin)
	 */
	public void setTile(int x, int y) {
		int adj = adjacents[x][y];
		Tile t; 
		if(hiddenBoard[x][y] == 1) {
			t = new Mine(tileDim, adj, 
					tileDim*x, tileDim*y);
		}
		else {
			t = new Grass(tileDim, adj, 
					tileDim*x, tileDim*y);
		}
		
		boardTiles[x][y] = t;
	}
	
	/**
	 * Populates the hiddenBoard array with 1's and 0's at random
	 * to represent Mines and Grass Tiles respectively. 
	 */
	public void initializeTiles() {
		double bound = 
				(double)numMines/(double)(dim*dim); 
		
		int minesIn = 0;
		
		while(minesIn < numMines) {
			for(int i = 0; i < dim; i++) {
				if(minesIn == numMines) {
					break;
				}
				for(int j = 0; j < dim; j++) {
					double r = Math.random(); 
					if(minesIn == numMines) {
						break;
					}

					if(r < bound) {
						int org = hiddenBoard[i][j];
						System.out.println(org); 
						if(org != 1) {
							hiddenBoard[i][j] = 1; 
							minesIn++; 
						}
					}			
				}
			}
		}
		setAdjacent();
		setTiles(); 
	}
	
	/**
	 * Recursively clears mines adjacent to the Tile while Tiles have no adjacent mines
	 * @param i The x coordinate of the starting Tile (With a top-left origin)
	 * @param j The y coordinate of the starting Tile (With a top-left origin)
	 */
	public void clear(int i,  int j) {
		for(int x = i-1; x <= i+1; x++) {
			for(int y = j-1; y <= j+1; y++) {
				if(inBounds(x) && inBounds(y)
				  ) {
					Tile t = boardTiles[x][y];
					if(!t.isRevealed 
						&&!t.isFlagged &&!t.isMine()) {
						t.reveal();
						numRevealed++; 
						if(t.isClear()) {
							clear(x,y); 
						}
					}
						
				}
			}
		}
	}
	
	
	/**
	 * Reveals all the Mines
	 */
	private void revealMines() {
		for(int i = 0; i < dim; i++) {
			for(int j = 0; j < dim; j++) {
				if(boardTiles[i][j].isMine()) {
					boardTiles[i][j].reveal();
				}
			}
		}
		isBombed = true; 
	}
	
	/**
     * Starts the game at starting state
     */
    public void start() {
    	isPlaying = true;
        status.setText("Running...");
    }
	
	/*
	 * Paints the game Board. 
	 */
    @Override 
	public void paintComponent(Graphics g) {
		for(int i = 0; i < dim ; i ++) {
			for(int j = 0; j < dim; j ++) {
				boardTiles[i][j].paintComponent(g);
			}
		}
	}
    
    @Override
    public Dimension getPreferredSize() {
        return new Dimension(BOARD_DIM, BOARD_DIM);
	}
    
    /**
     * Reveals a specific Tile. 
     * @param x The x coordinate of the Tile (With a top-left origin)
	 * @param y The y coordinate of the Tile (With a top-left origin)
     */
    public void reveal(int x, int y) {
    	Tile t = boardTiles[x][y]; 
    	if (t.isMine() &&!t.isFlagged){
			revealMines();  
		}
        else if (t.isClear() &&!t.isFlagged) {
        	t.reveal();
        	numRevealed++; 
        	clear(x, y); 
        }
        else if(!t.isFlagged) {
        	t.reveal();
        	numRevealed++; 
        }
		
    }
    
    /**
     * Flags a specific Tile. 
     * @param x The x coordinate of the Tile (With a top-left origin)
	 * @param y The y coordinate of the Tile (With a top-left origin)
     */
    public void flag(int x, int y) {
    	Tile t = boardTiles[x][y]; 
        if(!t.isRevealed) {
        	t.flag(); 
        	if(t.isFlagged) {
	        	numFlagged++; 
	        	
	        }
	        else {
	        	numFlagged--; 
	        }
        }	
    }
    
    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~methods for testing ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    /**
     * 
     * @return boolean stating whether or not the game is still playable
     */
    public boolean isPlaying() {
    	if(isBombed || numRevealed 
    			== dim*dim - numMines) {
    		return false;
    	}
    	return true; 
    }
    
    public int[][] getHiddenBoard(){
    	return hiddenBoard.clone(); 
    }
    
    public Tile[][] getTiles(){
    	return boardTiles.clone();  
    }
    
    public int[][] getAdjacents(){
    	return adjacents.clone(); 
    }
    
    /**
     * Sets a Mine at a specific Tile on the board
     * @param x The x coordinate of the Tile (With a top-left origin)
	 * @param y The y coordinate of the Tile (With a top-left origin)
     */
    public void setMine(int x, int y) {
    	hiddenBoard[x][y] = 1; 
    	numMines++;
    	setAdjacent();
    }
    
    /**
     * 
     * @return the number of revealed mines
     */
    public int getNumRevealed() {
    	int x = numRevealed;
    	return x;
    }
    
  
}
	
